# A0076520L
###### \src\logic\DoTask.java
``` java

package logic;

import shared.*;
import storage.Storage;
import java.util.ArrayList;
import shared.Keywords;

public class DoTask extends Functionality {

	/**
	 * This method allows the user to mark task as completed
	 * 
	 * @param taskID
	 *            the taskID is used to search for the task in the storage
	 * @return it will return successful when a task is marked as completed,
	 *         else otherwise.
	 */

	public Notification doTask(ArrayList<Integer> taskIds) {
		Notification n = new Notification();
		ArrayList<Integer> validIds = new ArrayList<Integer>();
		for (int id : taskIds) { // fliters out non-existent ids
			if (Storage.getTask(id) != null) {
				validIds.add(id);
			}
		}
		// check if the validIds is empty
		if (validIds.isEmpty()) {
			n.setTitle(Keywords.MESSAGE_ERROR);
		} else if (validIds.size() > 1) { // shows that there will be definitely
											// more than 1 task been completed
			n.setTitle(Keywords.MESSAGE_COMPLETED_SUCCESS);
			n.setMessage(validIds.toString());
		} else {// there is only 1 task to be completed
			n.setTitle(Keywords.MESSAGE_COMPLETED_SUCCESS);
			n.setMessage(Storage.getTask(validIds.get(Keywords.FIRST_ELEMENT)).getUserFormat() + "done!");
		}
		for (int taskID : validIds) {
			doTask(taskID);
		}
		// Add to history the action to be done
		super.addToHistory("do");
		super.synchronization();
		return n;
	}

	/**
	 * Set the task to be completed
	 * 
	 * @param taskID
	 *            the ID to retrieve the task
	 * @return true if task is set as completed or false if it is not found
	 */
	private boolean doTask(int taskID) {
		Task t = Storage.getTask(taskID);
		if (doesTaskExist(t)) {
			return false;
		}
		super.addToFuncTasks(t);
		t.setIsCompleted(Keywords.TASK_COMPLETED);
		return true;
	}

	/**
	 * Check if the task is null
	 * 
	 * @param t
	 *            the task to be checked
	 * @return the truth value of t == null;
	 */
	private boolean doesTaskExist(Task t) {
		return t == null;
	}
}
```
###### \src\logic\Functionality.java
``` java

package logic;

import java.util.ArrayList;

import parser.Formatter;
import shared.Task;
import storage.Storage;
import shared.*;

public class Functionality extends Logger {

	private ArrayList<Task> tasks = new ArrayList<Task>();
	private Notification notification = new Notification();

	/**
	 * Synchronize the file with the active list
	 */
	protected void synchronization() {
		Storage.writeTasksToFile();
	}

	/**
	 * Add the action and set of tasks to History
	 * @param action
	 *            the action to be added
	 */
	protected void addToHistory(String action) {
		Storage.addToHistory(tasks, action);
	}

	/**
	 * Obtain a list of tasks this Function is currently using
	 * @return the list of tasks
	 */
	protected ArrayList<Task> getTasks() {
		return tasks;
	}

	/**
	 * Create a new task object and add to this list
	 * @param task
	 * 			the task to be added
	 */
	protected void addToFuncTasks(Task task) {
		Task newt = new Task();
		newt.setId(task.getId());
		newt.setCategories(task.getCategories());
		newt.setDate(task.getDate());
		newt.setDateTimes(task.getDateTimes());
		newt.setTask(task.getTask());
		newt.setIsCompleted(task.getIsCompleted());
		newt.setIntDate(task.getIntDate());
		newt.setStartTime(Formatter.getDateTimes(Integer.toString(task.getIntStartTime())).get(Keywords.INDEX_STARTTIME));
		newt.setEndTime(Formatter.getDateTimes(Integer.toString(task.getIntEndTime())).get(Keywords.INDEX_ENDTIME));
		newt.setPriority(task.getPriority());
		tasks.add(newt);
	}

	/**
	 * Set the title for Notification
	 * @param title
	 * 			the String to be input
	 */
	protected void setNTitle(String title) {
		notification.setTitle(title);
	}

	/**
	 * Set the message for Notification
	 * @param msg
	 * 			the String to be input
	 */
	protected void setNMessage(String msg) {
		notification.setMessage(msg);
	}

	/**
	 * Obtain the Notification of this Function
	 * @return the Notification object
	 */
	protected Notification getNotification() {
		return notification;
	}
}
```
###### \src\logic\SearchTask.java
``` java

package logic;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Map;

import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Collections;
import org.ocpsoft.prettytime.shade.org.apache.commons.lang.WordUtils;

import parser.Formatter;
import shared.Keywords;
import shared.Task;
import storage.Storage;
import storage.SymSpell;

public class SearchTask extends Functionality {

	private ArrayList<String> replace;
	private HashMap<Integer, Integer> busiest;

	/**
	 * Search the tasks accordingly to the attributes given
	 * 
	 * @param words
	 *            the words to be filtered
	 * @param isPriortise
	 *            1 for priortise, 0 for not priortise
	 * @param month
	 *            the month to be searched
	 * @param date
	 *            the specific date to be searched
	 * @param categories
	 *            the categories to be filtered
	 * @return the results of the filtering
	 */
	public HashMap<String, Object> searchTask(String words, int isPriortise, String month, int date,
			ArrayList<String> categories, int isBusiest, String conflict) {
		replace = new ArrayList<String>();
		busiest = new HashMap<Integer, Integer>();
		replace.add("Do you mean:");
		HashMap<String, Object> results = new HashMap<String, Object>();
		ArrayList<Task> result = new ArrayList<Task>();
		int isCheckPerformed = 0;

		// search for conflicts
		if (!conflict.equals(Keywords.EMPTY_STRING)) {
			result = FreeSlots.findConflict();
			isCheckPerformed++;
		} else {
			result = Storage.getListOfUncompletedTasks();
		}

		// Check if user wants to search for prioritise, no prioritise or get
		// all uncompleted
		if (isPriortise == 1 || isPriortise == 0) {
			result = filterPriority(result, isPriortise);
			isCheckPerformed++;
		}

		// Compare the dates
		if (date != -1) {
			// search <result> comparing dates
			result = filterDate(result, date);
			// get free time slots
			ArrayList<String> freeSlots = FreeSlots.getFreeSlots(date);
			if (freeSlots.isEmpty()) {
				freeSlots.add("Whole day is free");
			}
			results.put("free", freeSlots);
			isCheckPerformed++;
		}

		// search by month
		if (!month.equals(Keywords.EMPTY_STRING)) {
			result = filterByMonth(result, month);
			isCheckPerformed++;
			if (isBusiest == Keywords.YES) {// check if user wants to search for
											// busiest
				int max = (int) Collections.max(busiest.values());// find the
																	// highest
																	// value
				ArrayList<String> busyDays = new ArrayList<String>();
				busyDays.add(" in " + WordUtils.capitalizeFully(month) + " with " + max + " task(s).");
				for (Map.Entry<Integer, Integer> e : busiest.entrySet()) {
					if (max == e.getValue()) {// find the days with the highest
												// value
						if (e.getKey() == 1) {
							busyDays.add("On the " + e.getKey() + "st");
						} else if (e.getKey() == 2) {
							busyDays.add("On the " + e.getKey() + "nd");
						} else if (e.getKey() == 3) {
							busyDays.add("On the " + e.getKey() + "rd");
						} else {
							busyDays.add("On the " + e.getKey() + "th");
						}
					}
				}
				results.put("busiest", busyDays);
			}
		}

		// search by categories
		if (!categories.isEmpty()) {
			result = filterCategories(result, categories);
			isCheckPerformed++;
		}

		// Lastly, after all the filtering, search for words containing if any
		if (!words.equals("")) {
			result = filterWords(result, words);
			isCheckPerformed++;
		}
		if (result.size() == 0) {
			setNTitle("Search Success!");
			setNMessage("No results found!");
		} else if (isCheckPerformed == 0) {// isCheckPerformed = 0 would mean
											// user's input is wrong
			result.clear();
			setNTitle("Search Error!");
			setNMessage("Your input format is wrong!");
		} else {
			setNTitle("Search Success!");
			setNMessage("Results found: " + result.size());
		}

		// combines all of it into results and return to caller
		ArrayList<Object> combined = new ArrayList<Object>();
		combined.add(getNotification());
		results.put("Tasks", result);
		results.put("notification", getNotification());
		results.put("replace", replace);
		combined.add(result);
		return results;
	}

	/**
	 * Filter by key words
	 * 
	 * @param list
	 *            the list of tasks to be filtered
	 * @param words
	 *            the words to filter
	 * @return the list of filtered tasks
	 */
	private ArrayList<Task> filterWords(ArrayList<Task> list, String words) {
		ArrayList<Task> temp = new ArrayList<Task>();
		for (Task t : list) {
			for (String word : words.split(Keywords.SPACE_STRING)) {
				ArrayList<String> result = SymSpell.Correct(word, Keywords.EMPTY_STRING);
				if (t.getTask().contains(word)) {// check if task contains the
													// word itself
					temp = checkTask(temp, t);
					break;
				}
				if (t.getCategories().contains(word)) {// check if task's
														// categories contains
														// the word itself
					temp = checkTask(temp, t);
					break;
				}
				for (String replacement : result) {// check if any replacement
													// words found
					if (t.getTask().contains(replacement)) {// check if it
															// contains the
															// replacement word
						addWordToReplace(word, replacement);
						temp = checkTask(temp, t);
						break;
					} else if (!t.getCategories().isEmpty()) {// check if its
																// categories
																// contains the
																// replacement
																// word
						if (t.getCategories().contains(replacement)) {
							addWordToReplace(word, replacement);
							temp = checkTask(temp, t);
							break;
						}
					}
				}
			}
		}
		return temp;
	}

	/**
	 * Check if task is exists in list
	 * 
	 * @param tasks
	 *            list of tasks
	 * @param task
	 *            task to check
	 * @return the list of tasks
	 */
	private ArrayList<Task> checkTask(ArrayList<Task> tasks, Task task) {
		if (!tasks.contains(task)) {
			tasks.add(task);
		}
		return tasks;
	}

	/**
	 * Check if word in dictionary match and if it already exists in the
	 * ArrayList
	 * 
	 * @param toReplace
	 * @param toCheck
	 */
	private void addWordToReplace(String toReplace, String toCheck) {
		if (!toCheck.equals(toReplace) && !replace.contains(toCheck)) {
			// if it is not in ArrayList, add it in, else ignore
			replace.add(toCheck);
		}
	}

	/**
	 * Filter the list of tasks by date
	 * 
	 * @param list
	 *            the list of tasks to be filtered
	 * @param date
	 *            the date to filter
	 * @return the filtered list
	 */
	private ArrayList<Task> filterDate(ArrayList<Task> list, int date) {
		ArrayList<Task> temp = new ArrayList<Task>();
		for (Task t : list) {
			boolean isTaskCompleted = t.getIsCompleted() == Keywords.TASK_NOT_COMPLETED;
			if (t.getIntDate() == date && isTaskCompleted) {
				// checks the start date
				temp.add(t);
			} else if (t.getIntDateEnd() == date && isTaskCompleted) {
				// checks end date
				temp.add(t);
			} else {
				// check date range
				int start = t.getIntDate();
				int end = t.getIntDateEnd();
				while (start <= end && end != 9999) {
					if (start == date && isTaskCompleted) {
						temp.add(t);
						break;
					}
					start++;
				}
			}
		}
		return temp;
	}

	/**
	 * Filter the list of tasks by priority
	 * 
	 * @param list
	 *            the list of tasks to be filtered
	 * @param isPriortise
	 *            the priority
	 * @return the list of filtered tasks
	 */
	private ArrayList<Task> filterPriority(ArrayList<Task> list, int isPriortise) {
		ArrayList<Task> temp = new ArrayList<Task>();
		for (Task t : list) {
			if (t.getPriority() == isPriortise && t.getIsCompleted() == Keywords.TASK_NOT_COMPLETED) {
				// checks for priority based on the isPrioritise variable
				temp.add(t);
			}
		}
		return temp;
	}

	/**
	 * Filter the list of tasks by categories
	 * 
	 * @param list
	 *            the list of tasks to be filtered
	 * @param catToFilter
	 *            the categories to filter
	 * @return the list of filtered tasks
	 */
	private ArrayList<Task> filterCategories(ArrayList<Task> list, ArrayList<String> catToFilter) {

		ArrayList<Task> temp = new ArrayList<Task>();
		for (Task t : list) {
			for (String cat : catToFilter) {
				if (t.getCategories().contains(cat)) {
					temp.add(t);
					break;
				}
			}
		}
		return temp;
	}

	/**
	 * Filter the list of tasks by month
	 * 
	 * @param list
	 *            the list of tasks to be filtered
	 * @param month
	 *            the month to filter
	 * @return the list of filtered tasks
	 */
	private ArrayList<Task> filterByMonth(ArrayList<Task> list, String month) {
		ArrayList<Task> temp = new ArrayList<Task>();
		busiest.clear();
		for (Task t : list) {
			// initialise all variables needed
			String intStartDate = Integer.toString(t.getIntDate());
			String intEndDate = Integer.toString(t.getIntDateEnd());
			Calendar startDateOfTask = null;
			Calendar endDateOfTask = null;
			Calendar dateMth = Calendar.getInstance();
			if (Formatter.fromIntToDate(intStartDate) != null) {// if start date
																// is found
				startDateOfTask = Calendar.getInstance();
				startDateOfTask.setTime(Formatter.fromIntToDate(intStartDate));
			}
			if (Formatter.fromIntToDate(intEndDate) != null) {// if end date is
																// found
				endDateOfTask = Calendar.getInstance();
				endDateOfTask.setTime(Formatter.fromIntToDate(intEndDate));
			}
			Date userMth = getUserMth(month);// check if the format of month is
												// correct
			if (userMth != null) {
				dateMth.setTime(userMth);
			}
			boolean isStart = (startDateOfTask != null && dateMth != null)
					? startDateOfTask.get(Calendar.MONTH) == dateMth.get(Calendar.MONTH) : false;
			boolean isEnd = (endDateOfTask != null && dateMth != null)
					? endDateOfTask.get(Calendar.MONTH) == dateMth.get(Calendar.MONTH) : false;
			if (isStart) {
				temp = checkTask(temp, t);
			}
			if (isEnd) {
				temp = checkTask(temp, t);
			}
			// filter busiest just in case if user needs it
			filterBusiest(startDateOfTask, endDateOfTask, dateMth.get(Calendar.MONTH));
		}
		return temp;
	}

	/**
	 * Get Date of the month of what user wants
	 * 
	 * @param month
	 *            the month to get
	 * @return the Date object
	 */
	private Date getUserMth(String month) {
		Date mth = null;
		try {
			mth = new SimpleDateFormat("MMM", Locale.ENGLISH).parse(month);
		} catch (Exception e) {
			setNMessage("Wrong date format. Use Feb, may, Jan.");
		}
		return mth;
	}

	/**
	 * Tabulate the busiest HashMap for finding busiest day
	 * 
	 * @param start
	 *            the starting Calendar
	 * @param end
	 *            the ending Calendar
	 * @param userMth
	 *            the month user wants
	 */
	private void filterBusiest(Calendar start, Calendar end, int userMth) {
		boolean isStart = (start != null) ? start.get(Calendar.MONTH) == userMth : false;
		boolean isEnd = (end != null) ? end.get(Calendar.MONTH) == userMth : false;

		if (start != null && end != null) {
			if (start.get(Calendar.MONTH) == end.get(Calendar.MONTH) && isStart) {
				int day = start.get(Calendar.DAY_OF_MONTH);
				while (day <= end.get(Calendar.DAY_OF_MONTH)) {
					addToBusiest(day);
					start.add(Calendar.DAY_OF_MONTH, 1);
					day = start.get(Calendar.DAY_OF_MONTH);
				}

			} else if (isStart || isEnd) {
				Calendar toUse = Calendar.getInstance();
				toUse.setTime((isEnd) ? end.getTime() : start.getTime());
				boolean toSameEnd = toUse.get(Calendar.MONTH) == end.get(Calendar.MONTH);
				boolean toSameStart = toUse.get(Calendar.MONTH) == start.get(Calendar.MONTH);
				if (toSameEnd) {
					int day = toUse.get(Calendar.DAY_OF_MONTH);

					while (toSameEnd) {
						addToBusiest(day);
						toUse.add(Calendar.DAY_OF_MONTH, -1);
						day = toUse.get(Calendar.DAY_OF_MONTH);
						toSameEnd = toUse.get(Calendar.MONTH) == end.get(Calendar.MONTH);
					}
				} else {
					int day = toUse.get(Calendar.DAY_OF_MONTH);

					while (toSameStart) {
						addToBusiest(day);
						toUse.add(Calendar.DAY_OF_MONTH, 1);
						day = toUse.get(Calendar.DAY_OF_MONTH);
						toSameStart = toUse.get(Calendar.MONTH) == start.get(Calendar.MONTH);
					}
				}
			}
		} else if (start != null) {
			if (isStart) {
				int day = start.get(Calendar.DAY_OF_MONTH);
				addToBusiest(day);
			}
		}
	}

	/**
	 * Add to the busiest HashMap
	 * 
	 * @param day
	 *            the day to add to
	 */
	private void addToBusiest(int day) {
		if (busiest.get(day) != null) {
			busiest.put(day, busiest.get(day) + 1);
		} else {
			busiest.put(day, 1);
		}
	}

}
```
###### \src\logic\UndoTask.java
``` java

package logic;

import java.util.ArrayList;

import parser.Formatter;
import shared.Keywords;
import shared.Task;
import storage.Storage;

public class UndoTask extends Functionality {

	/**
	 * Check the logic for undoing a task
	 * 
	 * @return the Notification object
	 */
	public Notification undoTask() {
		ArrayList<Task> t = Storage.getLastTasks();
		String action = Storage.getLastAction();
		Notification n = new Notification();
		switch (action) {
		case "do":// handles the reverse of do
			for (Task task : t) {
				Storage.getTask(task.getId()).setIsCompleted(Keywords.TASK_NOT_COMPLETED);
			}
			n = printSuccessful("Complete command undone");
			break;
		case "add":// handles the reverse of add
			for (Task task : t) {
				Storage.recycleId(task.getId());
				Storage.removeTaskUsingTaskId(task.getId());
			}
			n = printSuccessful("Add command undone");
			break;
		case "edit":// handles the reverse of edit
			for (Task task : t) {
				// change back to the original values
				Storage.getTask(task.getId()).setDate(task.getDate());
				Storage.getTask(task.getId()).setIntDate(task.getIntDate());
				Storage.getTask(task.getId()).setCategories(task.getCategories());
				Storage.getTask(task.getId()).setDateTimes(task.getDateTimes());
				Storage.getTask(task.getId()).setIsCompleted(task.getIsCompleted());
				Storage.getTask(task.getId()).setPriority(task.getPriority());
				Storage.getTask(task.getId()).setTask(task.getTask());
				Storage.getTask(task.getId()).setStartTime(Formatter.getDateTimes(Integer.toString(task.getIntStartTime())).get(Keywords.INDEX_STARTTIME));
				Storage.getTask(task.getId()).setEndTime(Formatter.getDateTimes(Integer.toString(task.getIntEndTime())).get(Keywords.INDEX_ENDTIME));
			}
			n = printSuccessful("Edit command undone");
			break;
		case "delete":// handles the reverse of delete
			for (Task task : t) {
				Storage.addTaskToList(task);
				Storage.removeSpecificId(task.getId());
			}
			n = printSuccessful("Delete command undone");
			break;
		case "mark":// handles the reverse of mark
			for (Task task : t) {
				Storage.getTask(task.getId()).togglePriority();
			}
			n = printSuccessful("Mark command undone");
			break;
		}
		// if t does not contain anything
		if (t == null) {
			n.setTitle("Undo Failed.");
			n.setMessage("Nothing to undo!");
		}

		super.synchronization();
		return n;
	}

	/**
	 * Set up the Notification Object
	 * 
	 * @param toUpdate
	 *            the String to be input
	 * @return the Notification object
	 */
	private Notification printSuccessful(String toUpdate) {
		Notification n = new Notification();
		n.setTitle("Undo Successful.");
		n.setMessage(toUpdate);
		return n;
	}
}
```
###### \src\logic\ViewHelp.java
``` java

package logic;

import java.util.LinkedList;

public class ViewHelp extends Functionality {

	/**
	 * Set up the help sheet for user
	 * 
	 * @return the list of Strings to display as help
	 */
	public LinkedList<String> viewHelp() {
		LinkedList<String> help = new LinkedList<String>();
		help.add("Adding tasks");
		help.add("add <TODO>");
		help.add("add <TODO> (at | by | on | to) <date> [#category]");
		help.add("Eg. add do CS2103 tutorial by 10 May");
		help.add("      add buy milk by 15Feb #shopping");
		
		help.add("Edit tasks");
		help.add("edit <task_ID#> to <date>");
		help.add("Eg. edit 1 to 15Feb");
		
		help.add("Delete tasks");
		help.add("delete <task_ID#>");
		help.add("Eg. delete 1 2");
		
		help.add("Searching tasks");
		help.add("search \"<TODO>\"");
		help.add("search \"<TODO>\" <date>");
		help.add("search <date>");
		help.add("search (busiest | priority) (from | in) <date>");
		help.add("Eg. search \"networking\"");
		help.add("      search \"networking\" 14 apr");
		help.add("      search May");
		help.add("      search busiest from Apr");
		
		help.add("Set priority");
		help.add("mark <task_ID#>");
		help.add("Eg. mark 2 3");
		
		help.add("Complete Tasks");
		help.add("do <TODO | task_ID#>");
		help.add("Eg. do receive quest");
		help.add("      do 1");
		
		help.add("View tasks");
		help.add("view [category]");
		help.add("Eg. view shopping");
		help.add("      view");
		
		help.add("Show help");
		help.add("[help | h | ?]");
		
		help.add("Undo previous command");
		help.add("[undo | u]");
		
		help.add("Keyboard shortcuts");
		help.add("Launch application: CTRL + ALT + D");
		help.add("Choose file location: ALT + E");
		help.add("Exit program: ESC");
		
		return help;
	}
}
```
###### \src\parser\ParseEdit.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Arrays;

import logic.Logic;
import logic.Notification;
import shared.Keywords;

public class ParseEdit {

	private static int id;

	private static final String REGEX_TIME = "(((1[012]|[1-9])(:[0-5][0-9])?\\s?(?i)(am|pm))|([01]?[0-9]|2[0-3]):[0-5][0-9])";
	private static final String REGEX_DATE = "(0?[1-9]|[12][0-9]|3[01])\\s?"
			+ "(?i)(January|February|March|April|May|June|July|" + "August|September|October|November|December|"
			+ "Jan|Feb|Mar|Apr|Jun|Jul|Aug|Sep|Oct|Nov|Dec)";
	private static final String REGEX_CAT = "(\\#+[a-zA-Z0-9.\\;]+\\s*)+";
	private static final String REGEX_ID = "^\\d+";
	private static final String NO_DATE = "NO DATE";
	private static final String NO_TIME = "NO TIME";
	private static Pattern p;
	private static Matcher m;

	private static ArrayList<Date> datetimes;
	private static ArrayList<String> categories;
	private static int resetDate, resetTime;
	private static String userInput;

	/**
	 * Interpret and dissect the user's input
	 * 
	 * @param userInput
	 *            user Input
	 * @return the Notification object
	 */
	public static Notification editTask(String rawInput) {
		datetimes = new ArrayList<Date>();
		categories = new ArrayList<String>();
		p = null;
		m = null;
		resetDate = 0;
		resetTime = 0;
		userInput = rawInput;
		String taskName = Keywords.EMPTY_STRING;
		for (int i = 0; i < 4; i++) {
			datetimes.add(null);
		}
		// check if user wants reset date or time
		checkResetDateOrTime();
		// find categories
		findCategory();
		// find the ID from the input
		findID();
		// find dates
		findDates();
		// find times
		findTimes();
		// find task description
		taskName = userInput;

		return Logic.editTask(id, datetimes, taskName, categories, resetDate, resetTime);
	}

	/**
	 * Check if user is resetting Date or Time to null
	 */
	private static void checkResetDateOrTime() {
		if (userInput.contains(NO_DATE)) {
			resetDate = 1;
			userInput = userInput.replace(NO_DATE, Keywords.EMPTY_STRING);
		}

		if (userInput.contains(NO_TIME)) {
			resetTime = 1;
			userInput = userInput.replace(NO_TIME, Keywords.EMPTY_STRING);
		}
	}

	/**
	 * Find the categories in the user input
	 */
	private static void findCategory() {
		p = Pattern.compile(REGEX_CAT);
		m = p.matcher(userInput);
		while (m.find()) {
			ArrayList<String> cats = new ArrayList<String>(Arrays.asList(m.group().split(Keywords.SPACE_STRING)));
			for (String cat : cats) {
				categories.add(cat.replace("#", Keywords.EMPTY_STRING));
			}
			userInput = userInput.replaceAll(REGEX_CAT, Keywords.EMPTY_STRING);
		}
	}

	/**
	 * Find the ID in the user input
	 */
	private static void findID() {
		String result = find(REGEX_ID, userInput);
		if (result == null) {
			id = -1;
		} else {
			try {
				id = Integer.parseInt(result);
			} catch (NumberFormatException e) {
				id = -1;
			}
			userInput = userInput.replaceAll(REGEX_ID + "(?:\\sto\\s)?", Keywords.EMPTY_STRING);
		}
	}

	/**
	 * Find the dates in the user input
	 */
	private static void findDates() {
		String startDate = "(?<=from|on|by|at)\\s" + REGEX_DATE;
		String result = find(startDate, userInput);
		if (result != null) {// may have multiple dates
			datetimes.set(Keywords.INDEX_STARTDATE, Formatter.getDateFromString(result));
			userInput = userInput.replaceAll("(from|on|by|at)\\s" + REGEX_DATE + "\\s?", Keywords.EMPTY_STRING);
			findEndDate();
		} else {// single date or no date
			startDate = "^" + REGEX_DATE;
			result = find(startDate, userInput);
			if (result != null) {
				datetimes.set(Keywords.INDEX_STARTDATE, Formatter.getDateFromString(result));
				userInput = userInput.replaceAll(startDate + "\\s?", Keywords.EMPTY_STRING);
				findEndDate();
			}
		}
	}

	/**
	 * Find the times in the user input
	 */
	private static void findTimes() {
		String startTime = "(?<=from|on|by|at)\\s" + REGEX_TIME;
		String result = find(startTime, userInput);
		if (result != null) {// may have multiple times
			datetimes.set(Keywords.INDEX_STARTTIME, Formatter.getDateFromString(result));
			userInput = userInput.replaceAll("(from|on|by|at)\\s" + REGEX_TIME + "\\s?", Keywords.EMPTY_STRING);
			findEndTime();
		} else {// may have a single start time
			startTime = "^" + REGEX_TIME;
			result = find(startTime, userInput);
			if (result != null) {
				datetimes.set(Keywords.INDEX_STARTTIME, Formatter.getDateFromString(result));
				userInput = userInput.replaceAll(startTime + "\\s?", Keywords.EMPTY_STRING);
				findEndTime();
			}
		}
	}

	/**
	 * Find the end date of the input
	 */
	private static void findEndDate() {
		String endDate = "(?<=to)\\s" + REGEX_DATE;
		String result = find(endDate, userInput);
		if (result != null) {// may have end date
			datetimes.set(Keywords.INDEX_ENDDATE, Formatter.getDateFromString(result));
			userInput = userInput.replaceAll("to\\s" + REGEX_DATE + "\\s?", Keywords.EMPTY_STRING);
		}
	}

	/**
	 * Find the end time of the input
	 */
	private static void findEndTime() {
		String endTime = "(?<=to)\\s" + REGEX_TIME;
		String result = find(endTime, userInput);
		if (result != null) {// may have a end time
			datetimes.set(Keywords.INDEX_ENDTIME, Formatter.getDateFromString(result));
			userInput = userInput.replaceAll("to\\s" + REGEX_TIME + "\\s?", Keywords.EMPTY_STRING);
		}
	}

	/**
	 * Find if it matches the regex of the input
	 * 
	 * @param regex
	 *            the regex to be matched
	 * @param input
	 *            the input to be matched with
	 * @return the finding of the result
	 */
	private static String find(String regex, String input) {
		p = Pattern.compile(regex);
		m = p.matcher(input);
		if (m.find()) {
			return m.group();
		} else {
			return null;
		}
	}
}
```
###### \src\parser\ParseSearch.java
``` java

package parser;

import java.util.ArrayList;
import java.util.Date;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import shared.Keywords;

public class ParseSearch {

	private static final String NO_PRIORITY = "no priority";
	private static final String PRIORITY = "priority";
	private static final String REGEX_CHECKMTH = "(?:from|in)\\s(?i)"
			+ "(jan|feb|mar|apr|may|jun|jul|aug|sep|oct|nov|dec|" 
			+ "january|february|march|april|may|june|july|august|"
			+ "september|october|november|december)";
	private static final String REGEX_DESC = "\"([^\"]*)\"";
	private static final String REGEX_CAT = "(\\#[^\\s]+)";

	/**
	 * Interpret the user's input
	 * 
	 * @param rawInput
	 * @return
	 */
	public static ArrayList<Object> filterInput(String rawInput) {
		ArrayList<Object> output = new ArrayList<Object>();
		// filter for words
		Pattern p = Pattern.compile(REGEX_DESC);
		Matcher m = p.matcher(rawInput);
		if (!m.find()) {
			// if it cannot find anything with "", add an empty string
			output.add("");
		} else {
			output.add(m.group(1));
		}
		// remove the words to be searched
		rawInput = removeString(REGEX_DESC, rawInput);

		// check for user asking for priority
		if (rawInput.contains(NO_PRIORITY)) {
			rawInput = removeString(NO_PRIORITY, rawInput);
			output.add(0);
		} else if (rawInput.contains(PRIORITY)) {
			rawInput = removeString(PRIORITY, rawInput);
			output.add(1);
		} else {
			// user wants both priority and no priority
			output.add(-1);
		}

		// filter for dates
		// check if it is by month only
		p = Pattern.compile(REGEX_CHECKMTH);
		m = p.matcher(rawInput);
		if (m.find()) {
			output.add(m.group(1));
			rawInput = removeString(REGEX_CHECKMTH, rawInput);
		} else {
			output.add(Keywords.EMPTY_STRING);
		}

		// check if there is any dates
		Date date = Formatter.getDateFromString(rawInput);
		int dateStart = -1;
		if (date != null) {
			dateStart = Formatter.fromDateToInt(date);
		}
		output.add(dateStart);
		
		// filter for categories
		p = Pattern.compile(REGEX_CAT);
		m = p.matcher(rawInput);
		boolean hasCategory = m.find();
		if (!hasCategory) {
			output.add(new ArrayList<String>());
		} else {
			ArrayList<String> list = new ArrayList<String>();
			list.add(m.group(1).replace((Keywords.CATEGORY_PREPEND), Keywords.EMPTY_STRING));
			while (m.find()) {
				list.add(m.group(1).replace((Keywords.CATEGORY_PREPEND), Keywords.EMPTY_STRING));
			}
			output.add(list);
		}
		
		//filter for busiest
		p = Pattern.compile("busiest");
		m = p.matcher(rawInput);
		if(m.find()){
			output.add(1);
		}else{
			output.add(0);
		}
		
		//filter for conflict
		if (rawInput.matches(Keywords.REGEX_CONFLICT)) {
			output.add(rawInput);
		} else {
			output.add(Keywords.EMPTY_STRING);
		}
		return output;
	}

	/**
	 * Remove matched regex from String
	 * 
	 * @param toR
	 *            Regex to be matched
	 * @param input
	 *            Input to be remove
	 * @return the input which the regex has been removed
	 */
	private static String removeString(String toR, String input) {
		return input.replaceAll(toR, Keywords.EMPTY_STRING);
	}
}
```
###### \src\parser\ParseUndo.java
``` java

package parser;

import logic.Logic;
import logic.Notification;

public class ParseUndo {

	/**
	 * Call the Logic's undoTask method
	 * @return the Notification Object
	 */
	public static Notification undoTask(){
		return Logic.undoTask();
	}
}
```
###### \src\storage\Categories.java
``` java

package storage;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import shared.Keywords;
import shared.Task;

public class Categories {

	private static HashMap<String, Integer> noOfTasksPerCat;

	/**
	 * Initialize the variables
	 */
	protected static void init() {
		noOfTasksPerCat = new HashMap<>();
	}

	/**
	 * Add a count to the category name and store in the HashMap
	 * 
	 * @param category
	 *            the category to be incremented
	 */
	protected static void addACountToCat(ArrayList<String> category) {
		for (String cat : category) {
			if (noOfTasksPerCat.get(cat) == null) {
				noOfTasksPerCat.put(cat, 1);
			} else {
				noOfTasksPerCat.put(cat, noOfTasksPerCat.get(cat) + 1);
			}
		}
	}

	/**
	 * Remove a count from the category name and remove the category if it
	 * reaches 0
	 * 
	 * @param category
	 *            the category to be decremented
	 */
	protected static void removeACountFromCat(ArrayList<String> category) {
		for (String cat : category) {
			if (noOfTasksPerCat.get(cat) == null) {
				continue;
			}
			if (noOfTasksPerCat.get(cat) <= 0) {
				noOfTasksPerCat.remove(cat);
			} else {
				noOfTasksPerCat.put(cat, noOfTasksPerCat.get(cat) - 1);
			}
		}
	}

	/**
	 * Get a list of categories with the total number of tasks
	 * 
	 * @param tasks
	 *            the tasks to be accounted for
	 * @return the list of categories with its count
	 */
	protected static ArrayList<String> getListOfCategoriesWithCount(ArrayList<Task> tasks) {
		int uncompletedTasks = 0;
		for (Task t : tasks) {
			if (t.getIsCompleted() == Keywords.TASK_NOT_COMPLETED) {
				uncompletedTasks++;
				for (String cat : t.getCategories()) {
					if (!cat.equals(Keywords.EMPTY_STRING)) {
						int currentCount = (noOfTasksPerCat.get(cat) == null) ? 0 : noOfTasksPerCat.get(cat);
						currentCount++;
						noOfTasksPerCat.put(cat, currentCount);
					}
				}
			}
		}
		// format the list to be displayed
		Iterator<Map.Entry<String, Integer>> it = noOfTasksPerCat.entrySet().iterator();
		ArrayList<String> temp = new ArrayList<>();
		while (it.hasNext()) {
			Map.Entry<String, Integer> pair = it.next();
			temp.add(pair.getKey() + Keywords.SPACE_STRING + "(" + pair.getValue() + ")");
		}
		temp.add("Uncompleted (" + uncompletedTasks + ")");
		// clear off the old list of categories
		noOfTasksPerCat.clear();
		return temp;
	}

	/**
	 * Filter the list of tasks by the categories
	 * 
	 * @param categories
	 *            the categories to be matched
	 * @param tasks
	 *            the tasks to be filtered
	 * @return the list of tasks filtered or empty list if none matched
	 */
	protected static ArrayList<Task> getTasksByCat(ArrayList<String> categories, ArrayList<Task> tasks) {
		ArrayList<Task> taskList = new ArrayList<Task>();
		for (Task t : tasks) {
			ArrayList<String> taskCats = t.getCategories();
			for (String cat : categories) {
				if (taskCats.contains(cat)) {
					taskList.add(t);
					break;
				}
			}
		}
		return taskList;
	}
}
```
###### \src\storage\FreeIDs.java
``` java

package storage;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.LinkedList;

import shared.Keywords;

public class FreeIDs {

	private static LinkedList<Integer> freeIDs;
	private static int currentTaskId;
	
	/**
	 * Initialize the variables
	 */
	protected static void init(){
		freeIDs = new LinkedList<Integer>();
		currentTaskId = 0;
	}
	
	/**
	 * A clear public method for callers
	 * @return
	 * 		the next available ID
	 */
	public int getNextAvailID(){
		return getNextAvailableID();
	}
	
	/**
	 * Check if the list is empty and generate ID using generateID()
	 * else poll ID from the list
	 * @return
	 * 		the next ID
	 */
	protected static int getNextAvailableID() {
		sortIDs();
		if (freeIDs.isEmpty()) {
			generateID();
		}
		return freeIDs.poll();
	}

	/**
	 * Add the ID to the list
	 * @param id
	 * 			the ID to be added
	 */
	protected static void addToFreeId(int id) {
		//detects if there are any repeated IDs
		if(!freeIDs.contains(id)){
			freeIDs.offerFirst(id);
		}
	}
	
	/**
	 * Remove the specific ID from the list
	 * @param id
	 * 			the ID to be removed
	 */
	protected static void removeSpecificId(int id){
		boolean foundID = false;
		for(int i : freeIDs){
			if(i==id){
				foundID = true;
			}
		}
		if(foundID==true){
			freeIDs.remove(new Integer(id));
		}
	}
	
	/**
	 * Convert the list of ID to String for storing in file
	 * @return
	 * 		the string form of IDs
	 */
	protected static String convertIDListToString() {
		String stringID = Keywords.EMPTY_STRING;
		if (freeIDs.isEmpty()) {
			generateID();
		}
		for(int id : freeIDs){
			stringID += id + Keywords.SPACE_STRING;
		}
		return stringID.trim();
	}
	
	/**
	 * Convert the String to an Integer object and store it in the list
	 * @param s
	 * 		the String to be converted
	 */
	protected static void convertIDStringToList(String s) {
		ArrayList<String> stringOfIds = new ArrayList<String>(Arrays.asList(s.split(Keywords.SPACE_STRING)));
		for (String id : stringOfIds) {
			freeIDs.offerFirst(Integer.parseInt(id));
		}
		setCurrentID(freeIDs.peek());
		sortIDs();
	}

	/**
	 * sort the IDs in ascending order
	 */
	private static void sortIDs() {
		Collections.sort(freeIDs);
	}

	/**
	 * set the currentID to be the ID next
	 * @param id
	 * 			the ID to be set
	 */
	private static void setCurrentID(int id) {
		currentTaskId = id;
	}

	/**
	 * Generate the next ID and store it in list
	 */
	private static void generateID() {
		freeIDs.offer(++currentTaskId);
	}

}
```
###### \src\storage\History.java
``` java

package storage;

import java.util.ArrayList;
import java.util.LinkedList;

import shared.Keywords;
import shared.Task;

public class History {
	private static LinkedList<ArrayList<Task>> historyList;
	private static LinkedList<String> actionList;
	
	/**
	 * Initialize the variables
	 */
	protected static void initHistory(){
		historyList = new LinkedList<ArrayList<Task>>();
		actionList = new LinkedList<String>();
	}
	
	/**
	 * Obtain the last set of tasks from the list
	 * @return 
	 * 		the last set of tasks or null if there are no tasks
	 */
	protected static ArrayList<Task> getLastTasks(){
		if(historyList.isEmpty()){
			return null;
		}
		return historyList.poll();
	}
	
	/**
	 * Obtain the last action performed by the user
	 * @return 
	 * 		the last action or empty string if there are no action
	 */
	protected static String getLastAction(){
		if(actionList.isEmpty()){
			return Keywords.EMPTY_STRING;
		}
		return actionList.poll();
	}
	
	/**
	 * Peek the list to check the last set of tasks stored in the history
	 * @return 
	 * 		the peeked set of tasks or null if there are no tasks
	 */
	protected static ArrayList<Task> peekLastTask(){
		if(historyList.isEmpty()){
			return null;
		}
		return historyList.peek();
	}
	
	/**
	 * Store the set of tasks and action to the variables
	 * @param tasks 
	 * 			the set of tasks to store
	 * @param action 
	 * 			the action to store
	 */
	protected static void addActionToHistory(ArrayList<Task> tasks, String action){
		historyList.addFirst(tasks);
		actionList.addFirst(action);
	}
	
}
```
###### \src\storage\ReadWrite.java
``` java

package storage;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;

import shared.Task;
import shared.Keywords;
import shared.Logger;

public class ReadWrite {
	
	private static final String ERROR_MSG = "ReadWrite Error Msg";
	
	/**
	 * Method to read the data from file and store it in the list
	 * @param list 
	 * 			Obtain an arraylist to add tasks to
	 */
	protected static void readTasksFromFile(ArrayList<Task> list) {
		BufferedReader bufferReader = null;
		try {
			bufferReader = new BufferedReader(new FileReader(Keywords.filePath));

			String currentLine = Keywords.EMPTY_STRING;
			while ((currentLine = bufferReader.readLine()) != null) {
				if (currentLine.contains(Keywords.STORE_DELIMITER)) {
					list.add(Task.formatStringToObject(currentLine));
				} else {
					FreeIDs.convertIDStringToList(currentLine);
				}
			}
		} catch (FileNotFoundException ex) {
			Logger.logf(ERROR_MSG, "File was not found.");
		} catch (IOException ex) {
			Logger.logf(ERROR_MSG, "Usage of BufferReader IOException caught.");
		} finally {
			try {
				if (bufferReader != null) {
					bufferReader.close();
				}
			} catch (IOException ex) {
				Logger.logf(ERROR_MSG, " Closing of BufferReader IOException caught.");
			}
		}
	}

	/**
	 * Method to write tasks to file
	 * @param list 
	 * 			Obtain a list of tasks to write to file
	 */
	protected static void writeTasksToFile(ArrayList<Task> list) {
		try {
			BufferedWriter bufferWriter = new BufferedWriter(new FileWriter(Keywords.filePath));
			for (int index = 0; index < list.size(); index++) {
				bufferWriter.write(Task.formatObjectToString(list.get(index)));
				bufferWriter.newLine();
			}
			bufferWriter.write(FreeIDs.convertIDListToString());
			bufferWriter.close();
		} catch (IOException ex) {
			Logger.logf(ERROR_MSG, "Usage of BufferWriter IOException caught.");
		}
	}

}
```
###### \src\storage\Storage.java
``` java

package storage;

import java.io.InputStream;
import java.util.ArrayList;

import shared.Keywords;
import shared.Task;

public class Storage {

	// FORMAT OF EACH TASK: [taskID]|[task]|[sdate]|[edate]|
	// [stime]|[etime]|[categories]|[isComplete]|[priority]
	private static ArrayList<Task> tasks;
	private static Storage storage;

	/**
	 * Initialize the variables
	 */
	private Storage() {
		tasks = new ArrayList<Task>();
		Categories.init();
		FreeIDs.init();
		History.initHistory();
		ReadWrite.readTasksFromFile(tasks);
		InputStream is = getClass().getResourceAsStream("/storage/dictionary");
		SymSpell.CreateDictionary(is, Keywords.EMPTY_STRING);
	}

	/**
	 * Obtain the instance of the Storage
	 * 
	 * @return the instance of the storage
	 */
	public static Storage getInstance() {
		if (storage == null) {
			storage = new Storage();
		}
		return storage;
	}

	/**
	 * Obtain a list of tasks
	 * 
	 * @return a list of tasks
	 */
	public static ArrayList<Task> getListOfTasks() {
		return tasks;
	}

	/**
	 * Obtain a list of uncompleted tasks by calling getTasksBasedOnStatus(int);
	 * 
	 * @return a list of uncompleted tasks
	 */
	public static ArrayList<Task> getListOfUncompletedTasks() {
		return getTasksBasedOnStatus(Keywords.TASK_NOT_COMPLETED);
	}

	/**
	 * Obtain a list of completed tasks by calling getTasksBasedOnStatus(int);
	 * 
	 * @return a list of completed tasks
	 */
	public static ArrayList<Task> getListOfCompletedTasks() {
		return getTasksBasedOnStatus(Keywords.TASK_COMPLETED);
	}

	/**
	 * Retrieves the tasks based on the status
	 * 
	 * @param status
	 *            either completed or not completed
	 * @return the results obtained
	 */
	private static ArrayList<Task> getTasksBasedOnStatus(int status) {
		ArrayList<Task> temp = new ArrayList<>();
		for (Task t : tasks) {
			if (t.getIsCompleted() == status) {
				temp.add(t);
			}
		}
		return temp;
	}

	/**
	 * Get the task based on its ID
	 * 
	 * @param taskID
	 *            the ID of the task to get
	 * @return the task or null if cannot be found
	 */
	public static Task getTask(int taskID) {
		for (Task t : tasks) {
			if (t.getId() == taskID) {
				return t;
			}
		}
		return null;
	}

	/**
	 * Obtain the next availableID using FreeIDs class
	 * 
	 * @return the next ID to be given to the task
	 */
	public static int getNextAvailableID() {
		return FreeIDs.getNextAvailableID();
	}

	/**
	 * Add the task into the list
	 * 
	 * @param task
	 *            the task to be added
	 */
	public static void addTaskToList(Task task) {
		tasks.add(task);
	}

	/**
	 * Remove the task using the Task ID
	 * 
	 * @param taskId
	 *            the task to be removed
	 */
	public static void removeTaskUsingTaskId(int taskId) {
		Task task = getTask(taskId);
		if (task != null) {
			Categories.removeACountFromCat(getTask(taskId).getCategories());
			tasks.remove(getTask(taskId));
		}
	}

	/**
	 * Remove specific ID from the FreeIDs class
	 * 
	 * @param id
	 *            the ID to be removed
	 */
	public static void removeSpecificId(int id) {
		FreeIDs.removeSpecificId(id);
	}

	/**
	 * Add the ID to the FreeIDs class
	 * 
	 * @param id
	 *            the ID to be added
	 */
	public static void recycleId(int id) {
		FreeIDs.addToFreeId(id);
	}

	/**
	 * Write the tasks to the file
	 */
	public static void writeTasksToFile() {
		ReadWrite.writeTasksToFile(tasks);
	}

	/**
	 * Read the file to obtain the tasks
	 */
	public static void readTasksFromFile() {
		tasks.clear();// clear any existing data from the list
		ReadWrite.readTasksFromFile(tasks);
	}

	/**
	 * Obtain a list of categories by call the Categories class
	 * 
	 * @return a list of categories with its count
	 */
	public static ArrayList<String> getListOfCategoriesWithCount() {
		return Categories.getListOfCategoriesWithCount(tasks);
	}

	/**
	 * Get the list of tasks by categories
	 * 
	 * @param categoriesList
	 *            the list of categories to obtain
	 * @return the list of tasks based on categories or empty list
	 */
	public static ArrayList<Task> getTasksByCat(ArrayList<String> categoriesList) {
		ArrayList<Task> temp = new ArrayList<Task>();
		for (Task t : Categories.getTasksByCat(categoriesList, tasks)) {
			if (t.getIsCompleted() == Keywords.TASK_NOT_COMPLETED) {
				temp.add(t);
			}
		}
		return temp;
	}

	/**
	 * add the set of tasks and action to History class
	 * 
	 * @param tasks
	 *            the set of tasks to be added
	 * @param action
	 *            the action to be added
	 */
	public static void addToHistory(ArrayList<Task> tasks, String action) {
		History.addActionToHistory(tasks, action);
	}

	/**
	 * Poll the last set of tasks from the History class
	 * 
	 * @return the last set of tasks
	 */
	public static ArrayList<Task> getLastTasks() {
		return History.getLastTasks();
	}

	/**
	 * Peek the last set of tasks in the History class
	 * 
	 * @return the last set of tasks peeked
	 */
	public static ArrayList<Task> peekLastTask() {
		return History.peekLastTask();
	}

	/**
	 * Poll the last action performed through History class
	 * 
	 * @return the last action performed
	 */
	public static String getLastAction() {
		return History.getLastAction();
	}

	/**
	 * Check if the tasks contain the category
	 * 
	 * @param cat
	 *            the category to be matched
	 * @return the boolean result of the matching
	 */
	public static boolean containsCat(String cat) {
		boolean bool = false;
		for (Task t : tasks) {
			if (t.getCategories().contains(cat)) {
				bool = true;
			}
		}
		return bool;
	}

}
```
###### \src\test\integrated\AddingTasksTest.java
``` java

package test.integrated;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;
import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Arrays;

import logic.Notification;
import parser.Formatter;
import parser.ParseAdd;
import parser.Parser;
import shared.Task;
import storage.Storage;

public class AddingTasksTest {


	ArrayList<Task> tasks = new ArrayList<Task>();
	
	@Test
	public void addTasksTest() {
		Parser parser = Parser.getInstance();
		Storage storage = Storage.getInstance();
		//ArrayList<Task> tasks = new ArrayList<Task>();

		// Floating tasks with commands
		Notification n = (Notification) parser.parse("add add add add addadd");
		Task t = new Task();
		t.setTask("add add add addadd");
		tasks.add(t);
		assertTrue(t.like(ParseAdd.getTask()));

		n = (Notification) parser.parse("add undo complete delete do view search");
		t = new Task();
		t.setTask("undo complete delete do view search");
		tasks.add(t);
		assertTrue(t.like(ParseAdd.getTask()));
		
		//add task with #11pm as category
		n = (Notification) parser.parse("add this task #11pm");
		t = new Task();
		t.setTask("this task");
		String[] ss = { "11pm" };
		ArrayList<String> cats = new ArrayList<String>(Arrays.asList(ss));
		t.setCategories(cats);
		tasks.add(t);
		assertTrue(t.like(ParseAdd.getTask()));

		// Floating tasks with special characters and categories
		n = (Notification) parser.parse("add \\/>#,|<.@~$%^&*!)(+_-|}{\";:");
		t = new Task();
		t.setTask("\\/>#,<.@~$%^&*!)(+_-}{\";:");
		tasks.add(t);
		assertTrue(t.like(ParseAdd.getTask()));

		n = (Notification) parser.parse("add test~1 #)(!# #test(#@# #####");
		t = new Task();
		t.setTask("test~1");
		String[] s = { ")", ")(!#", "test(#@#", "####" };
		ArrayList<String> cat = new ArrayList<String>(Arrays.asList(s));
		t.setCategories(cat);
		tasks.add(t);
		assertTrue(t.like(ParseAdd.getTask()));
		
		// Inputs that would definitely result in errors
		// Floating task with empty string
		n = (Notification) parser.parse("add ");
		assertEquals("Error!", n.getTitle());
		
		n = (Notification) parser.parse("add #withnospace by 23 Mar from 3pm to 5pm");
		assertEquals("Error!", n.getTitle());
		n = (Notification) parser.parse("add ##### by 23 Mar");
		assertEquals("Error!", n.getTitle());
		
		//Check if each task in temp storage and actual storage are the same
		for(Task sTask: Storage.getListOfTasks()){
			boolean test = false;
			for(Task te: tasks){
				if(te.like(sTask)){
					test = true;
					break;
				}
			}
			assertTrue(test);
		}
		
		/*
		//descriptions carried at the back
		n = (Notification) parser
				.parse("add tesing this task ##### by 23 Mar #### #category1 @!(#)&!)(@*$)(!@*#98)@#*()@#)}{[]");
		assertEquals("Error!", n.getTitle());
		
		//lack of prepositions at time
		n = (Notification) parser.parse("add testing \\/>#,|<.@~$%^&*!)(+_-|}{\";: this task by 23 Mar 3pm");
		assertEquals("Error!", n.getTitle());
		*/
	}

}
```
###### \src\test\integrated\CompletingTasksTest.java
``` java

package test.integrated;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Arrays;

import logic.Notification;
import parser.Parser;
import shared.Task;
import storage.Storage;

public class CompletingTasksTest {

	ArrayList<Task> tasks = new ArrayList<Task>();
	Parser parse = Parser.getInstance();
	Storage S = Storage.getInstance();
	@Before
	public void populateList(){
		Storage.getInstance();
		Task t = new Task();
		t.setTask("add add add addadd");
		t.setId(1);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(2);
		t.setTask("undo complete delete do view search");
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(3);
		t.setTask("\\/>#,|<.@~$%^&*!)(+_-|}{\";:");
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(4);
		t.setTask("test~1");
		String[] s = { ")", ")(!#", "test(#@#", "####", "cat" };
		ArrayList<String> cat = new ArrayList<String>(Arrays.asList(s));
		t.setCategories(cat);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(5);
		t.setTask("thistime#withnospace");
		t.setIntDate(87);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(6);
		t.setTask("random test1");
		String[] ss = { ")", ")(!#", "test(#@#", "####", "test"};
		cat = new ArrayList<String>(Arrays.asList(ss));
		t.setCategories(cat);
		t.setIntDate(87);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(7);
		t.setTask("random test2");
		t.setIntDate(87);
		tasks.add(t);
		S.addTaskToList(t);
	}
	
	@Test
	public void completingTasksTest() {
		//Normal deletions
				Notification n = (Notification) parse.parse("do 1");
				assertEquals("(#1) add add add addadd  ",n.getMessage());
				n = (Notification) parse.parse("do 1 2");
				assertEquals("(#2) undo complete delete do view search  ",n.getMessage());
				n = (Notification) parse.parse("delete 3 5");
				assertEquals("[3, 5]",n.getMessage());
				
				//delete non existing tasks
				n = (Notification) parse.parse("do 1999");
				assertEquals("Error!",n.getTitle());
				
				//deleting category by specifying # E.g. delete #cat
				n = (Notification) parse.parse("do all");
				assertEquals("Error!",n.getTitle());
				n = (Notification) parse.parse("do %cat");
				assertEquals("Error!",n.getTitle());
				
				//deleting with special characters
				n = (Notification) parse.parse("do @$%&");
				assertEquals("Error!",n.getTitle());
				
				//delete normal category delete cat
				n = (Notification) parse.parse("do cat");
				assertEquals("Tasks under [cat] categories have been deleted!",n.getMessage());
				
				//delete 2 categories
				n = (Notification) parse.parse("do #cat test  CS2103 CS2101 @cat");
				assertEquals("Tasks under [test] categories have been deleted!",n.getMessage());

				//delete by dates is not possible unless it is name of category
				n = (Notification) parse.parse("do 29Mar");
				assertEquals("Error!",n.getTitle());
				
				//delete delete should do nothing unless delete is a category
				n = (Notification) parse.parse("do do");
				assertEquals("Error!",n.getTitle());
				
				//delete by time is not possible unless it is name of category
				n = (Notification) parse.parse("do 11pm 10:00am");
				assertEquals("Error!",n.getTitle());
				
				//delete nothing
				n = (Notification) parse.parse("do ");
				assertEquals("Error!",n.getTitle());
				
				//delete all (to erase everything) is not possible unless all is a category
				n = (Notification) parse.parse("do @cat");
				assertEquals("Error!",n.getTitle());
				
				//delete by description is not possible
				n = (Notification) parse.parse("do <description of task>");
				assertEquals("Error!",n.getTitle());
				
				//delete by +
				n = (Notification) parse.parse("do +");
				assertEquals("Error!",n.getTitle());
				
				//delete categories within double quotes is not possible
				n = (Notification) parse.parse("do \"jm\" \'mj\'");
				assertEquals("Error!",n.getTitle());
	}

}
```
###### \src\test\integrated\DeletingTasksTest.java
``` java

package test.integrated;

import static org.junit.Assert.*;

import java.util.ArrayList;

import org.junit.Before;
import org.junit.Test;
import org.ocpsoft.prettytime.shade.edu.emory.mathcs.backport.java.util.Arrays;

import logic.Notification;
import parser.ParseAdd;
import parser.Parser;
import shared.Task;
import storage.Storage;

public class DeletingTasksTest {

	ArrayList<Task> tasks = new ArrayList<Task>();
	Parser parse = Parser.getInstance();
	Storage S = Storage.getInstance();
	@Before
	public void populateList(){
		Storage.getInstance();
		Task t = new Task();
		t.setTask("add add add addadd");
		t.setId(1);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(2);
		t.setTask("undo complete delete do view search");
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(3);
		t.setTask("\\/>#,|<.@~$%^&*!)(+_-|}{\";:");
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(4);
		t.setTask("test~1");
		String[] s = { ")", ")(!#", "test(#@#", "####", "cat" };
		ArrayList<String> cat = new ArrayList<String>(Arrays.asList(s));
		t.setCategories(cat);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(5);
		t.setTask("thistime#withnospace");
		t.setIntDate(87);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(6);
		t.setTask("random test1");
		String[] ss = { ")", ")(!#", "test(#@#", "####", "test"};
		cat = new ArrayList<String>(Arrays.asList(ss));
		t.setCategories(cat);
		t.setIntDate(87);
		tasks.add(t);
		S.addTaskToList(t);
		t = new Task();
		t.setId(7);
		t.setTask("random test2");
		t.setIntDate(87);
		tasks.add(t);
		S.addTaskToList(t);
	}
	
	@Test
	public void deleteTasksTest() {
		//Normal deletions
		Notification n = (Notification) parse.parse("delete 1");
		assertEquals("(#1) add add add addadd  ",n.getMessage());
		n = (Notification) parse.parse("delete 1 2");
		assertEquals("(#2) undo complete delete do view search  ",n.getMessage());
		n = (Notification) parse.parse("delete 3 5");
		assertEquals("[3, 5]",n.getMessage());
		
		//delete non existing tasks
		n = (Notification) parse.parse("delete 999");
		assertEquals("Error!",n.getTitle());
		
		//deleting category by specifying # E.g. delete #cat
		n = (Notification) parse.parse("delete #cat");
		assertEquals("Error!",n.getTitle());
		n = (Notification) parse.parse("delete %cat");
		assertEquals("Error!",n.getTitle());
		
		//deleting with special characters
		n = (Notification) parse.parse("delete @$%&");
		assertEquals("Error!",n.getTitle());
		
		//delete normal category delete cat
		n = (Notification) parse.parse("delete cat");
		assertEquals("Tasks under [cat] categories have been deleted!",n.getMessage());
		
		//delete 2 categories
		n = (Notification) parse.parse("delete #cat test  CS2103 CS2101");
		assertEquals("Tasks under [test] categories have been deleted!",n.getMessage());

		//delete by dates is not possible unless it is name of category
		n = (Notification) parse.parse("delete 29Mar");
		assertEquals("Error!",n.getTitle());
		
		//delete delete should do nothing unless delete is a category
		n = (Notification) parse.parse("delete delete");
		assertEquals("Error!",n.getTitle());
		
		//delete by time is not possible unless it is name of category
		n = (Notification) parse.parse("delete 11pm 10:00am");
		assertEquals("Error!",n.getTitle());
		
		//delete nothing
		n = (Notification) parse.parse("delete ");
		assertEquals("Error!",n.getTitle());
		
		//delete all (to erase everything) is not possible unless all is a category
		n = (Notification) parse.parse("delete all");
		assertEquals("Error!",n.getTitle());
		
		//delete by description is not possible
		n = (Notification) parse.parse("delete <description of task>");
		assertEquals("Error!",n.getTitle());
		
		//delete by +
		n = (Notification) parse.parse("delete +");
		assertEquals("Error!",n.getTitle());
		
		//delete categories within double quotes is not possible
		n = (Notification) parse.parse("delete \"jm\" \'mj\'");
		assertEquals("Error!",n.getTitle());
		
	}

}
```
